<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jugar cartón Bingo VL</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
      /* --- CSS MODIFICADO --- */
      html {
        height: 100%; /* Asegurar que html ocupe toda la altura */
      }
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex; /* Cambiado a flex para que app-container funcione bien */
        flex-direction: column;
        align-items: center;
        background: #f4f4f4;
        height: 100vh; /* Usar vh para altura completa viewport */
        overflow: hidden; /* Evitar scroll en body */
      }

      #app-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        /* min-height: 100%; /* Asegurar que llene la altura disponible */
      }

      #toolbar {
        display: flex;
        gap: 10px;
        padding: 10px;
        flex-wrap: wrap;
        background: #fff;
        border-bottom: 1px solid #ccc;
        justify-content: center;
        align-items: center;
        /* Evitar que la toolbar encoja */
        flex-shrink: 0;
      }

      .tool-group {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      button {
        padding: 8px 12px;
        font-size: 16px;
        border: none;
        background: #e3f2fd;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      button:hover {
        background: #bbdefb;
      }

      button i {
        font-size: 18px;
      }

      #canvas-container {
        flex: 1; /* Tomar el espacio restante */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Permitir scroll si el canvas es más grande que el contenedor */
        padding: 10px;
        /* Añadidos para mejorar el ajuste flex */
        min-height: 0;
        box-sizing: border-box; /* Incluir padding en el tamaño */
        width: 100%; /* Asegurar que ocupe el ancho */
      }

      canvas {
        background: #fff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        /* Añadidos para asegurar que el canvas no se desborde */
        display: block; /* Evita espacio extra debajo */
        max-width: 100%;
        max-height: 100%;
        object-fit: contain; /* Concepto similar para canvas */
      }

      input[type="color"] {
        width: 30px;
        height: 30px;
        border: 2px solid #ddd;
        border-radius: 50%;
        padding: 0;
      }

      input[type="range"] {
        width: 100px;
      }

      #carton-dropdown-container {
        position: relative;
      }

      #cartonDropdown {
        position: absolute;
        top: 100%;
        left: 0;
        width: 200px;
        max-height: 300px;
        overflow-y: auto;
        background: white;
        border: 1px solid #ccc;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: none;
        z-index: 100;
      }

      #cartonDropdown.show {
        display: block;
      }

      #current-carton {
        font-weight: bold;
        margin-left: 5px;
      }
      /* --- FIN CSS MODIFICADO --- */
    </style>
</head>
<body>
    <div id="app-container">
      <div id="toolbar">
        <div class="tool-group">
          <label title="Color del marcador">
            <i class="fas fa-palette"></i>
            <input type="color" id="colorPicker" value="#ff0000">
          </label>
        </div>

        <div class="tool-group">
          <label title="Tamaño del marcador">
            <i class="fas fa-brush"></i>
            <input type="range" id="brushSizeSlider" min="5" max="300" value="120" step="5">
            <span id="brushSizeValue">120px</span>
          </label>
        </div>

        <div class="tool-group">
          <label title="Transparencia">
            <i class="fas fa-adjust"></i>
            <input type="range" id="opacityRange" min="0.1" max="1" step="0.1" value="0.6">
          </label>
        </div>

        <div class="tool-group">
          <button onclick="undo()" title="Deshacer">
            <i class="fas fa-undo"></i>
          </button>
          <button onclick="redo()" title="Rehacer">
            <i class="fas fa-redo"></i>
          </button>
        </div>

        <div class="tool-group">
          <button onclick="save()" title="Guardar">
            <i class="fas fa-save"></i>
          </button>
        </div>

        <div class="tool-group" id="carton-dropdown-container">
          <button onclick="toggleDropdown()" title="Seleccionar cartón">
            <i class="fas fa-list-ol"></i>
            <span id="current-carton">Seleccionar</span>
          </button>
          <div id="cartonDropdown">
              </div>
        </div>


        <div class="tool-group">
          <button onclick="document.getElementById('fileInput').click()" title="Cargar imagen">
            <i class="fas fa-folder-open"></i>
          </button>
          <input type="file" id="fileInput" accept="image/*" style="display:none;">
        </div>

        <div class="tool-group">
          <button onclick="toggleFullscreen()" title="Pantalla completa">
            <i class="fas fa-expand"></i>
          </button>
        </div>
      </div>

      <div id="canvas-container">
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <script>
      // Elementos del DOM (...sin cambios...)
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const colorPicker = document.getElementById("colorPicker");
      const brushSizeSlider = document.getElementById("brushSizeSlider");
      const brushSizeValue = document.getElementById("brushSizeValue");
      const opacityRange = document.getElementById("opacityRange");
      const cartonDropdown = document.getElementById("cartonDropdown");
      const currentCartonDisplay = document.getElementById("current-carton");
      const fileInput = document.getElementById("fileInput");
      const canvasContainer = document.getElementById("canvas-container");
      const cartonDropdownContainer = document.getElementById('carton-dropdown-container');

      // Variables de estado (...sin cambios...)
      let drawing = false;
      let paths = [];
      let redoStack = [];
      let currentPath = null;
      let color = colorPicker.value;
      let size = +brushSizeSlider.value;
      let opacity = +opacityRange.value;
      let baseImage = new Image();
      let imageWidth, imageHeight;
      let isChanged = false; // <-- Flag para confirmación beforeunload
      let cartones = [];
      let scale = 1;
      let isImageLoaded = false;

      // Inicialización
      init();

      // --- init MODIFICADO ---
      async function init() {
          // 1. Comprobar parámetro URL ANTES de cargar lista
          const urlParams = new URLSearchParams(window.location.search);
          const cartonPathFromUrl = urlParams.get('carton'); // e.g., 'cartones/90-...jpg'

          // 2. Configurar listeners
          setupEventListeners();

          // 3. Cargar lista de cartones disponibles
          await loadCartonesList(); // Define 'cartones'

          // 4. Intentar cargar desde URL si existe el parámetro
          let loadedFromUrl = false;
          if (cartonPathFromUrl) {
              // Extraer solo el nombre del archivo para comparar con la lista
              const cartonFilenameFromUrl = cartonPathFromUrl.startsWith('cartones/')
                  ? cartonPathFromUrl.substring(9)
                  : null; // Asumimos que siempre tendrá el prefijo

              if (cartonFilenameFromUrl && cartones.includes(cartonFilenameFromUrl)) {
                  console.log("Loading carton from URL:", cartonFilenameFromUrl);
                  loadCarton(cartonFilenameFromUrl); // Carga el cartón
                  loadedFromUrl = true;
              } else {
                  console.warn("Carton from URL parameter not found or invalid:", cartonPathFromUrl);
                  currentCartonDisplay.textContent = "Cartón URL Inválido";
                  isImageLoaded = false; // Asegurar estado inicial
              }
          }

          // 5. Si no se cargó desde URL, establecer estado inicial
          if (!loadedFromUrl && !isImageLoaded) { // Doble check por si loadCarton falló
              isImageLoaded = false;
              currentCartonDisplay.textContent = "Seleccionar";
              resizeCanvas(); // Dibujar placeholder si no hay imagen
          }

          // 6. Resto de inicialización
          updateBrushSizeDisplay();
          document.addEventListener('fullscreenchange', () => {
              setTimeout(resizeCanvas, 150);
          });
          // resizeCanvas(); // Ya se llama dentro de la lógica de carga o en el else
      }
      // --- FIN init MODIFICADO ---

      // --- setupEventListeners MODIFICADO ---
      function setupEventListeners() {
          // Eventos de dibujo y controles (...sin cambios...)
          canvas.addEventListener("mousedown", startDrawing);
          canvas.addEventListener("mousemove", draw);
          canvas.addEventListener("mouseup", endDrawing);
          canvas.addEventListener("mouseout", endDrawing);
          canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
          canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
          canvas.addEventListener("touchend", handleTouchEnd);
          colorPicker.addEventListener("input", (e) => { color = e.target.value; });
          brushSizeSlider.addEventListener("input", (e) => { size = +e.target.value; updateBrushSizeDisplay(); });
          opacityRange.addEventListener("input", (e) => { opacity = +e.target.value; });
          fileInput.addEventListener("change", (e) => {
            if (e.target.files && e.target.files[0]) {
              loadImageFromFile(e.target.files[0]);
            }
          });
          window.addEventListener("resize", resizeCanvas);
          window.addEventListener('click', (e) => {
              if (!cartonDropdownContainer.contains(e.target)) {
                  cartonDropdown.classList.remove('show');
              }
          });

          // *** NUEVO: Listener para confirmación antes de salir/recargar ***
          window.addEventListener('beforeunload', (event) => {
              if (isChanged) {
                  // Mensaje estándar (el navegador mostrará su propio diálogo)
                  const confirmationMessage = 'Los cambios no guardados se perderán. ¿Estás seguro de que quieres salir?';
                  event.preventDefault(); // Necesario para la mayoría de navegadores
                  event.returnValue = confirmationMessage; // Necesario para navegadores más antiguos
                  return confirmationMessage; // Para algunos otros
              }
              // Si isChanged es false, no hacer nada (permite salir sin preguntar)
          });
          // *** FIN NUEVO ***
      }
       // --- FIN setupEventListeners MODIFICADO ---


      // --- Funciones de dibujo (startDrawing, draw, endDrawing) ---
      // Añadir isChanged = true; en el momento adecuado

      function startDrawing(e) {
          if (!isImageLoaded) return;
          e.preventDefault();
          drawing = true;
          const pos = getPosition(e);
          currentPath = {
              points: [{ x: pos.x / scale, y: pos.y / scale, color, size, opacity }],
              dots: []
          };
          drawDot(pos.x / scale, pos.y / scale, size, color, opacity);
          currentPath.dots.push({ x: pos.x / scale, y: pos.y / scale, size, color, opacity });
          // Considerar marcar isChanged aquí o en endDrawing
          // isChanged = true; // Marcar cambio al empezar a dibujar
      }

      function draw(e) {
          if (!drawing || !currentPath || !isImageLoaded) return;
          e.preventDefault();
          const pos = getPosition(e);
          const lastPoint = currentPath.points[currentPath.points.length - 1];
          const dist = Math.hypot(pos.x / scale - lastPoint.x, pos.y / scale - lastPoint.y);

          if (dist > size / 10) {
              currentPath.points.push({ x: pos.x / scale, y: pos.y / scale, color, size, opacity });
              redrawCanvas();
              isChanged = true; // Marcar cambio cuando se dibuja una línea
          }
      }

      function endDrawing() {
          if (!drawing || !isImageLoaded) return;
          drawing = false;
          if (currentPath && currentPath.points.length > 0) {
              paths.push(currentPath);
              redoStack = [];
              // Marcar cambio aquí asegura que un simple clic también active 'isChanged'
              isChanged = true;
          }
          currentPath = null;
      }

      // Funciones drawDot, redrawCanvas, drawPath (...sin cambios funcionales relevantes aquí...)
       function drawDot(x, y, size, color, opacity) {
          ctx.save();
          ctx.beginPath();
          // Coordenadas ya están escaladas al dibujar
          ctx.arc(x * scale, y * scale, (size * scale) / 2, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.globalAlpha = opacity;
          ctx.fill();
          ctx.restore();
      }

       function redrawCanvas() {
          clearCanvas();
          drawBaseImage();
          for (const path of paths) {
              if (path.points.length > 1) {
                  drawPath(path.points);
              }
              for (const dot of path.dots) {
                  drawDot(dot.x, dot.y, dot.size, dot.color, dot.opacity);
              }
          }
          if (currentPath) {
              if (currentPath.points.length > 1) {
                  drawPath(currentPath.points);
              }
          }
      }

       function drawPath(points) {
          if (points.length < 1) return;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(points[0].x * scale, points[0].y * scale);
          for (let i = 1; i < points.length; i++) {
              ctx.lineTo(points[i].x * scale, points[i].y * scale);
          }
          ctx.strokeStyle = points[0].color;
          ctx.lineWidth = points[0].size * scale;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.globalAlpha = points[0].opacity;
          ctx.stroke();
          ctx.restore();
      }

      // --- Funciones de imagen base, clearCanvas ---
      function drawBaseImage() {
        if (isImageLoaded && baseImage.complete && baseImage.naturalWidth !== 0) {
            ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
             if (!isImageLoaded || !baseImage.src) { // Mostrar solo si no hay imagen intentando cargar
                 ctx.fillStyle = '#aaaaaa';
                 ctx.font = '20px sans-serif';
                 ctx.textAlign = 'center';
                 ctx.fillText('Seleccione o cargue un cartón', canvas.width / 2, canvas.height / 2);
             }
        }
      }
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // --- resizeCanvas MODIFICADO (con logs comentados) ---
      function resizeCanvas() {
        const container = canvasContainer;
        // Usar clientWidth/Height que no incluye bordes/scrollbars si usamos border-box
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        // console.log(`resizeCanvas - Container W: ${containerWidth}, H: ${containerHeight}`); // DEBUG LOG

        if (!isImageLoaded || !baseImage.complete || baseImage.naturalWidth === 0) {
            // console.log("resizeCanvas - No image loaded, setting default size."); // DEBUG LOG
            // Ajustar tamaño placeholder (evitar tamaño 0)
            canvas.width = containerWidth > 20 ? containerWidth * 0.95 : 300;
            canvas.height = containerHeight > 20 ? containerHeight * 0.95 : 200;
            scale = 1;
            drawBaseImage(); // Dibuja placeholder
            return;
        }

        // console.log(`resizeCanvas - Image W: ${imageWidth}, H: ${imageHeight}`); // DEBUG LOG
        // Quitar el padding del cálculo del espacio disponible si usamos border-box
        const availableWidth = containerWidth - 20; // 10px padding left + 10px right
        const availableHeight = containerHeight - 20; // 10px padding top + 10px bottom

        if (availableWidth <= 0 || availableHeight <= 0) {
            // Evitar cálculos con dimensiones negativas o cero si el contenedor colapsa
            console.warn("resizeCanvas - Container dimensions too small after padding adjustment.");
            canvas.width = 10; canvas.height = 10; // Tamaño mínimo
            redrawCanvas();
            return;
        }

        const scaleX = availableWidth / imageWidth;
        const scaleY = availableHeight / imageHeight;
        scale = Math.min(scaleX, scaleY); // No multiplicar por 0.95 aquí, el padding ya se restó

        if (scale <= 0) scale = 0.1; // Evitar escala inválida

        // console.log(`resizeCanvas - Calculated scale: ${scale}`); // DEBUG LOG

        canvas.width = imageWidth * scale;
        canvas.height = imageHeight * scale;
        // console.log(`resizeCanvas - Set canvas size W: ${canvas.width}, H: ${canvas.height}`); // DEBUG LOG

        redrawCanvas();
      }
      // --- FIN resizeCanvas MODIFICADO ---

      // --- undo, redo (Asegurar que marcan isChanged) ---
      function undo() {
          if (paths.length > 0) {
              redoStack.push(paths.pop());
              isChanged = true; // Marcar cambio al deshacer
              redrawCanvas();
          }
      }
      function redo() {
          if (redoStack.length > 0) {
              paths.push(redoStack.pop());
              isChanged = true; // Marcar cambio al rehacer
              redrawCanvas();
          }
      }
      // --- FIN undo, redo ---

      // --- Funciones de carga de cartones (loadCartonesList) ---
      async function loadCartonesList() {
          try {
              const response = await fetch('cartones/list.json');
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              // Asegurarse que el content-type sea json
              const contentType = response.headers.get("content-type");
              if (!contentType || !contentType.includes("application/json")) {
                  throw new TypeError("Oops, we haven't got JSON!");
              }
              cartones = await response.json();
              if (!Array.isArray(cartones)) {
                   throw new Error('Formato de list.json no es un array');
              }
              populateCartonDropdown();
          } catch (error) {
              console.error('Error fatal al cargar/procesar la lista de cartones:', error);
              cartones = [];
              populateCartonDropdown(); // Mostrar mensaje de error en dropdown
              // Mostrar un error más visible al usuario
              currentCartonDisplay.textContent = "Error Lista";
              alert("Error grave: No se pudo cargar la lista de cartones (list.json).\nVerifique que el archivo exista, sea accesible y tenga el formato JSON correcto (un array de strings).\nDetalle: " + error.message);

          }
      }
      // --- FIN loadCartonesList ---


      // --- populateCartonDropdown MODIFICADO ---
      function populateCartonDropdown() {
          cartonDropdown.innerHTML = '';
          if (cartones.length === 0) {
              const item = document.createElement('div');
              item.textContent = 'No hay cartones disponibles';
              //...(estilos)...
              cartonDropdown.appendChild(item);
              return;
          }

          cartones.forEach(cartonName => { // cartonName es solo el nombre base, ej: 90-....jpg
              const item = document.createElement('div');
              const cartonNumber = cartonName.split('-').pop().replace('.jpg', '');
              item.textContent = `Cartón ${parseInt(cartonNumber)}`;
              //...(estilos)...
              item.style.padding = '8px 12px';
              item.style.cursor = 'pointer';
              item.addEventListener('mouseenter', () => item.style.backgroundColor = '#f0f0f0');
              item.addEventListener('mouseleave', () => item.style.backgroundColor = 'white');

              item.addEventListener('click', () => {
                  // 1. Cargar el cartón
                  loadCarton(cartonName);
                  cartonDropdown.classList.remove('show');

                  // 2. *** NUEVO: Actualizar URL ***
                  try {
                      const nextURL = `${window.location.origin}${window.location.pathname}?carton=cartones/${cartonName}`;
                      const nextTitle = `Cartón ${parseInt(cartonNumber)}`;
                      const nextState = { carton: cartonName };
                      window.history.pushState(nextState, nextTitle, nextURL);
                  } catch (e) {
                      console.error("Error updating URL with history.pushState:", e);
                      // No es crítico, la app sigue funcionando
                  }
                  // *** FIN NUEVO ***
              });
              cartonDropdown.appendChild(item);
          });
      }
      // --- FIN populateCartonDropdown MODIFICADO ---

      // --- loadCarton (resetear isChanged) ---
      function loadCarton(cartonName) { // cartonName es solo el nombre base
          const cartonPath = `cartones/${cartonName}`; // Construir path completo
          baseImage = new Image();
          baseImage.onload = function() {
              imageWidth = this.naturalWidth;
              imageHeight = this.naturalHeight;
              isImageLoaded = true;
              resizeCanvas();
              const cartonNumber = cartonName.split('-').pop().replace('.jpg', '');
              currentCartonDisplay.textContent = `#${parseInt(cartonNumber)}`;
              paths = [];
              redoStack = [];
              isChanged = false; // <-- Resetear cambios al cargar nuevo cartón
          };
          baseImage.onerror = function() {
              console.error("Error al cargar la imagen del cartón:", cartonPath);
              alert("No se pudo cargar el cartón: " + cartonName);
              isImageLoaded = false;
              resizeCanvas();
              currentCartonDisplay.textContent = "Error";
              isChanged = false; // Resetear aunque falle
          };
          isImageLoaded = false;
          imageWidth = 0;
          imageHeight = 0;
          currentCartonDisplay.textContent = "Cargando...";
          baseImage.src = cartonPath; // Asignar src al final
      }
      // --- FIN loadCarton ---

      // --- loadImageFromFile MODIFICADO (resetear isChanged y URL) ---
      function loadImageFromFile(file) {
          const reader = new FileReader();
          reader.onload = function(e) {
              baseImage = new Image();
              baseImage.onload = function() {
                  imageWidth = this.naturalWidth;
                  imageHeight = this.naturalHeight;
                  isImageLoaded = true;
                  resizeCanvas();
                  currentCartonDisplay.textContent = "Personalizado";
                  paths = [];
                  redoStack = [];
                  isChanged = false; // <-- Resetear cambios

                  // *** NUEVO: Resetear URL al cargar archivo ***
                  try {
                      const nextURL = window.location.origin + window.location.pathname; // Sin parámetros
                      const nextTitle = "Cartón Personalizado";
                      const nextState = { carton: 'personalizado' };
                      window.history.pushState(nextState, nextTitle, nextURL);
                  } catch (err) {
                       console.error("Error resetting URL:", err);
                  }
                   // *** FIN NUEVO ***
              };
              baseImage.onerror = function() {
                  console.error("Error al cargar la imagen desde archivo.");
                  alert("No se pudo cargar la imagen seleccionada.");
                  isImageLoaded = false;
                  resizeCanvas();
                  currentCartonDisplay.textContent = "Error";
                  isChanged = false; // <-- Resetear cambios
              };
              isImageLoaded = false;
              imageWidth = 0;
              imageHeight = 0;
              currentCartonDisplay.textContent = "Cargando...";
              baseImage.src = e.target.result;
          };
           reader.onerror = () => {
               console.error("Error al leer el archivo.");
               alert("Hubo un error al leer el archivo.");
               currentCartonDisplay.textContent = "Error";
               isChanged = false; // <-- Resetear cambios
           }
          reader.readAsDataURL(file);
      }
      // --- FIN loadImageFromFile MODIFICADO ---


      // --- save (resetear isChanged) ---
      function save() {
        if (!isImageLoaded) {
            alert("No hay cartón cargado para guardar.");
            return;
        }
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imageWidth;
        tempCanvas.height = imageHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(baseImage, 0, 0, imageWidth, imageHeight);
        for (const path of paths) {
            if (path.points.length > 1) {
                tempCtx.beginPath();
                tempCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    tempCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                tempCtx.strokeStyle = path.points[0].color;
                tempCtx.lineWidth = path.points[0].size;
                tempCtx.lineCap = "round";
                tempCtx.lineJoin = "round";
                tempCtx.globalAlpha = path.points[0].opacity;
                tempCtx.stroke();
            }
            for (const dot of path.dots) {
                tempCtx.beginPath();
                tempCtx.arc(dot.x, dot.y, dot.size / 2, 0, Math.PI * 2);
                tempCtx.fillStyle = dot.color;
                tempCtx.globalAlpha = dot.opacity;
                tempCtx.fill();
            }
        }
        const link = document.createElement('a');
        const cartonNumberText = currentCartonDisplay.textContent;
        let filenameSuffix = 'carton';
        if (cartonNumberText.startsWith('#')) {
            filenameSuffix = cartonNumberText.substring(1);
        } else if (cartonNumberText === 'Personalizado') {
            filenameSuffix = 'personalizado';
        }
        link.download = `bingo-${filenameSuffix}-marcado.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();

        isChanged = false; // <-- Resetear cambios al guardar
      }
      // --- FIN save ---

      // Funciones de interfaz (toggleDropdown, updateBrushSizeDisplay, toggleFullscreen) (...sin cambios...)
      function toggleDropdown() {
          cartonDropdown.classList.toggle('show');
      }
      function updateBrushSizeDisplay() {
          brushSizeValue.textContent = `${size}px`;
      }
      function toggleFullscreen() {
          if (!document.fullscreenElement) {
              document.documentElement.requestFullscreen().catch(err => {
                  console.error(`Error al intentar pantalla completa: ${err.message}`);
                  alert(`Error al entrar en pantalla completa: ${err.message}`);
              });
          } else {
              if (document.exitFullscreen) {
                  document.exitFullscreen();
              }
          }
      }

      // Manejo táctil (handleTouchStart, handleTouchMove, handleTouchEnd) (...sin cambios...)
       function handleTouchStart(e) { /* ... */ }
       function handleTouchMove(e) { /* ... */ }
       function handleTouchEnd(e) { /* ... */ }

      // Funciones auxiliares (getPosition) (...sin cambios...)
       function getPosition(e) {
          const rect = canvas.getBoundingClientRect();
          const clientX = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
          const clientY = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
          return {
              x: clientX - rect.left,
              y: clientY - rect.top
          };
       }

    </script>
</body>
</html>
